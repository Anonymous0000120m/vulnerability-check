#include <iostream>
#include <fstream>
#include <vector>
#include <stdexcept>
#include <string>
#include <random>
#include <ctime>
#include <tensorflow/c/c_api.h>
#include <tensorflow/cc/client/client_session.h>
#include <tensorflow/cc/ops/standard_ops.h>
#include <tensorflow/cc/ops/const_op.h>
#include <tensorflow/cc/saved_model/loader.h>
#include <tensorflow/cc/saved_model/tag_constants.h>
#include <tensorflow/core/framework/tensor.h>
#include <tensorflow/core/framework/graph.pb.h>
#include <tensorflow/core/public/session.h>
#include <tensorflow/core/protobuf/meta_graph.pb.h>

class Logger {
public:
    static void logInfo(const std::string &message) {
        std::cout << getCurrentTime() << " - INFO - " << message << std::endl;
    }

    static void logError(const std::string &message) {
        std::cerr << getCurrentTime() << " - ERROR - " << message << std::endl;
    }

private:
    static std::string getCurrentTime() {
        std::time_t now = std::time(nullptr);
        char buffer[100];
        std::strftime(buffer, sizeof(buffer), "%Y-%m-%d %H:%M:%S", std::localtime(&now));
        return buffer;
    }
};

class GeneratorModelLoader {
public:
    explicit GeneratorModelLoader(const std::string &filename) : filename(filename) {}

    std::unique_ptr<tensorflow::Session> loadGeneratorModel() {
        tensorflow::SavedModelBundle bundle;
        tensorflow::LoadSavedModel(tensorflow::SessionOptions(), tensorflow::RunOptions(), filename, {tensorflow::kServe}, &bundle);
        Logger::logInfo("Generator model loaded from " + filename);
        
        return std::move(bundle.session);
    }

private:
    std::string filename;
};

class DataGenerator {
public:
    explicit DataGenerator(std::unique_ptr<tensorflow::Session> &generatorModel) : generatorModel(std::move(generatorModel)) {}

    std::vector<std::vector<float>> generateData(int numSamples) {
        std::vector<std::vector<float>> generatedData(numSamples, std::vector<float>(784));  // Example output shape

        // Generate noise
        std::vector<float> noise(100 * numSamples);
        std::default_random_engine generator(static_cast<unsigned int>(std::time(nullptr)));
        std::normal_distribution<float> distribution;

        for (auto &value : noise) {
            value = distribution(generator);
        }

        // Prepare input tensor
        tensorflow::Tensor inputTensor(tensorflow::DT_FLOAT, {numSamples, 100});
        std::copy(noise.begin(), noise.end(), inputTensor.flat<float>().data());

        std::vector<tensorflow::Tensor> outputs;

        // Run prediction
        generatorModel->Run({{"input", inputTensor}}, {"output"}, &outputs);
        for (int i = 0; i < numSamples; ++i) {
            for (int j = 0; j < outputs[0].dim_size(1); ++j) {
                generatedData[i][j] = outputs[0].flat<float>()(i * outputs[0].dim_size(1) + j);
            }
        }

        return generatedData;
    }

private:
    std::unique_ptr<tensorflow::Session> generatorModel;
};

class CSVWriter {
public:
    explicit CSVWriter(const std::string &filename) : filename(filename) {}

    void writeToCSV(const std::vector<std::vector<float>> &data) {
        std::ofstream file(filename);
        if (!file) {
            Logger::logError("Could not open the file for writing: " + filename);
            throw std::runtime_error("File not found: " + filename);
        }

        // Write to CSV
        for (const auto &row : data) {
            for (size_t j = 0; j < row.size(); ++j) {
                file << row[j];
                if (j < row.size() - 1) {
                    file << ",";
                }
            }
            file << "\n";
        }
        file.close();
    }

private:
    std::string filename;
};

int main() {
    try {
        // Load the generator model
        GeneratorModelLoader loader("generator_model");
        auto generatorModel = loader.loadGeneratorModel();

        // Create data generator
        DataGenerator dataGenerator(std::move(generatorModel));

        // Generate data
        auto generatedData = dataGenerator.generateData(1000);

        // Write the generated data to CSV
        CSVWriter csvWriter("generated_data.csv");
        csvWriter.writeToCSV(generatedData);
    } catch (const std::exception &e) {
        Logger::logError("An error occurred: " + std::string(e.what()));
    }
    return 0;
}
